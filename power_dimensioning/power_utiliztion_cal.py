'''
1. Calculating the effective radiated power (ERP)
2. Predicted the power utilization and optimal radio type seperately from the ERP
3. Calculating the energy utilization (Wh) and estimated cost ($) for a given duration of time
'''

import pandas as pd
import numpy as np
from sklearn.preprocessing import LabelEncoder
from sklearn.tree import DecisionTreeRegressor

# globally declaring fit linear regression model variable to be used in other functions
global lm_power
global lm_rad_type


def power_util(df, ant_type):
    '''
    Calculates the Effective Radiated Power (ERP) using the formula: 
    ERP = tx_power * antenna_gain * feedline_loss

    Parameters
    ---------- 
    df: pandas dataframe
        dataframe generated by heuristic calculations
    params: dict
        antenna (transmitter and receiver) gains and losses

    Returns
    -------
    erp: int
        Effective Radiated Power
    '''
    params = {'tx_macro_gain': 16,
              'tx_micro_gain': 5,
              'tx_macro_losses': 1,
              'tx_micro_losses': 1, }

    if ant_type == 'macro':
        erp = list(map(
            lambda x: x * params['tx_macro_gain'] * params['tx_macro_losses'], df['power']))
    else:
        erp = list(map(
            lambda x: x * params['tx_micro_gain'] * params['tx_micro_losses'], df['power']))
    return erp


def rad_power(data):
    # encoding radios
    le = LabelEncoder()
    data['radio'] = le.fit_transform(data['radio'])
    data['area'] = le.fit_transform(data['area'])
    data['cell'] = le.fit_transform(data['cell'])

    data['range'] = np.log(data['range'])
    # data.drop('net', axis=1, inplace=True)
    y = data['power']
    X = data.drop("power", axis=1)
    global lm_power
    lm_power = DecisionTreeRegressor().fit(X, y)


def rad_power_predict(d):
    global lm_power
    le = LabelEncoder()
    d['radio'] = le.fit_transform(d['radio'])
    d['area'] = le.fit_transform(d['area'])
    d['cell'] = le.fit_transform(d['cell'])

    return lm_power.predict(d)


def rad_type(data):
    # encoding radios
    le = LabelEncoder()
    data['radio'] = le.fit_transform(data['radio'])
    data['area'] = le.fit_transform(data['area'])
    data['cell'] = le.fit_transform(data['cell'])

    data['range'] = np.log(data['range'])
    # data.drop('net', axis=1, inplace=True)

    y = data['radio']
    X = data.drop("radio", axis=1)
    global lm_rad_type
    lm_rad_type = DecisionTreeRegressor().fit(X, y)


def rad_type_predict(d):
    global lm_rad_type
    return lm_rad_type.predict(d)


def energy_util(p, n, t, mcs_index=0):
    '''
    Calculates the effective energy consumed by the specific service (distinguished using MCS index)

    Parameters
    ----------
    df: pandas dataframe
        dataframe generated by heuristic calculations
    p: int
        transmit power per prb pair
    n: int
        number of prb pairs
    t: int
        duration of transmit (in hours)
    mcs_index: int
        Modulation and Coding SCheme index of the particular service

    is the power offset of each optimal MCS to the basic MCS

    Returns
    -------
    energy: energy utilization : int (units = Watt-hour)
    '''
    # mcs_delta = mcs_i
    p_tot = p  # * mcs_delta * n
    energy = p_tot * n * t
    return energy


def driver():
    usd = 1  # cost of energy per unit

    data = pd.read_csv("power_dimensioning\data.csv")
    test_data_power = pd.read_csv("power_dimensioning\power_data.csv")
    test_data_rad = pd.read_csv("power_dimensioning/radio_data.csv")

    # converting ptx to erp
    data['power'] = power_util(data, 'micro')
    # fitting the model
    rad_power(data)
    # predicting the results
    pred_power = rad_power_predict(test_data_power)
    # getting the energy utilization for the predicted power
    energy = energy_util(pred_power, 1, 1)

    # calculating the cost
    cost = energy * usd

    # optimization - optimal radio type prediction
    rad_type(data)
    pred_rad = rad_type_predict(test_data_rad)
    pred_rad = np.array(map(lambda i: 'GSM' if i < 0.5 else 'UMTS', pred_rad))

    # results into dataframe
    res_power = test_data_power.copy()
    res_power['radio'], res_power['ERP'], res_power['Predicted Power'], res_power[
        'Energy Consumption'], res_power['Cost Estimation'] = data['radio'], data['power'], pred_power, energy, cost
    res_power.to_csv("power_dimensioning/power_results.csv", index=False)

    res_rad = test_data_rad.copy()
    res_rad['ERP'], res_rad['Optimal Radio Type'] = data['power'], pred_rad
    res_rad.to_csv("power_dimensioning/radio_results.csv", index=False)


def create_df():
    d = pd.DataFrame(columns=['radio', 'net', 'area',
                     'cell', 'lon', 'lat', 'range', 'power'])
    d.to_csv("data.csv")


# create_df()
driver()
